\section{Introduction}

With IoT techniques sweeping around the world, software systems are becoming more complicated, distributed and safety-critical, and thus the development of such systems is becoming notoriously difficult. Small failures in daily-used software, such as smart house controllers, payment applications, etc., may lead to severe butterfly effect. Under such circumstances, various approaches have been proposed in the past decades to help software development, such as object-oriented programming \cite{SebestaConceptsOfPL}, aspect-oriented programming \cite{Kiczales1997}, component-based modeling and development \cite{SGM03}, and so on. Among these approaches, component-based modeling is extremely popular and helpful in the development of embedded systems \cite{Cmkovic2005} and service-oriented applications \cite{ACKM04}.

\lang{} \cite{LiFacsMediator2017} is a new component-based modeling language that provides an automata-based formal semantics and supports hierarchical modeling. With the help of a full-featured type system and powerful coordination mechanisms, this language can be used by both domain-specific experts and software engineers to guarantee the reliability of software system models.

However, such powerful modeling languages can only help with the correctness of high-level models. In practice, lots of software errors are caused by the inconsistency between implementations and models. And it turns out that manual implementations do not always precisely follow abstract models and designs, especially for systems with high complexity. To address this problem, automatic code generation has been proposed to avoid errors caused by human activities in the implementation process \cite{Budinsky1996}. In this paper, we present an algorithm that generates C code from \lang{} models, which can be directly compiled and executed on Arduino \cite{margolis2011arduino}, a popular open-source embedded platform.

%\smalltitle{Related Work} 
Importance of code generation has been uncovered for a long time. As a result, a large number of formal and industrial code generation tools have been built for different target platforms. For example, Event-B \cite{FisherNfmEventBJava2016} and SCADE \cite{BerryScp1992} are very popular formal tools that can generate executable codes from abstract models. The code generator in SCADE is especially famous for its reliability, but its scalablity is restricted by the Esterel language it accepts. As a synchronous language, Esterel only formalizes a single embedded control loop, which makes it hard to model concurrent and timed behavior. Furthermore, both Event-B and SCADE code generators only aim at x86 platform, i.e. they cannot generate code that directly works on embedded systems. 

On the other hand, Ptolemy\cite{PtolemyBook2014}, MATLAB Simulink Toolbox\cite{hahn2016essentialsimulink} and LabVIEW\cite{labview} are the most famous industrial modeling tools that support platform-dependent code generation. These tools have large number of libraries and plug-ins that almost cover all commonly-used embedded platforms and programming languages. Nevertheless, power of these tools also becomes limitation when we try to perform testing or verification techniques on their models. For example, Ptolemy uses standard JAVA as its semantics, and Simulink enables users to write components directly through MATLAB language. As far as we know, models directly written in such full-featured programming languages, with loop and dynamic memory allocation, are very hard to be verified.

The rest of this paper is structured as follows: Section \ref{sec:background} briefly introduces the \lang{} language and the Arduino platform. Then in Section \ref{sec:codegen} we illustrate how the \lang{}-Arduino code generator works. Section \ref{sec:experiment} presents the wheeled-robot controller as a case study. Finally, Section \ref{sec:conclusion} concludes the paper.